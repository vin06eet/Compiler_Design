%option noyywrap
%option yylineno

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

static char* xstrdup(const char* s){
    if(!s) return NULL;
    size_t n=strlen(s)+1; char* p=(char*)malloc(n); if(p) memcpy(p,s,n); return p;
}
static char* xsubstr(const char* s, size_t a, size_t b){
    if(!s||b<a) return xstrdup("");
    size_t n=b-a; char* p=(char*)malloc(n+1); if(!p) return NULL;
    memcpy(p,s+a,n); p[n]='\0'; return p;
}
static char* trim(char* s){
    if(!s) return s;
    size_t n=strlen(s);
    size_t i=0; while(i<n && isspace((unsigned char)s[i])) i++;
    size_t j=n; while(j>i && isspace((unsigned char)s[j-1])) j--;
    size_t m=j-i; memmove(s, s+i, m); s[m]='\0'; return s;
}
static int is_ident_start_c(unsigned char c){ return (c=='_' || isalpha(c)); }
static int is_ident_char_c (unsigned char c){ return (c=='_' || isalnum(c)); }

typedef struct Symbol {
    char* name;
    char* type;            
    char* dimensions;      
    int   frequency;       
    char* return_type;     
    char* param_lists;     
    int   is_function;    
    struct Symbol* next;  
} Symbol;

#define SYM_HASH_SIZE 211
static Symbol* symtab[SYM_HASH_SIZE];

static unsigned long djb2(const char* str){
    unsigned long hash = 5381; int c;
    while((c = (unsigned char)*str++)) hash = ((hash << 5) + hash) + c;
    return hash;
}
static Symbol* sym_lookup(const char* name){
    unsigned long h = djb2(name) % SYM_HASH_SIZE;
    Symbol* s = symtab[h];
    while(s){ if(strcmp(s->name, name)==0) return s; s=s->next; }
    return NULL;
}
static Symbol* sym_insert(const char* name){
    unsigned long h = djb2(name) % SYM_HASH_SIZE;
    Symbol* s = (Symbol*)calloc(1, sizeof(Symbol));
    s->name = xstrdup(name);
    s->frequency = 0;
    s->next = symtab[h];
    symtab[h] = s;
    return s;
}
static Symbol* sym_touch(const char* name){
    Symbol* s = sym_lookup(name);
    if(!s) s = sym_insert(name);
    s->frequency++;
    return s;
}
static void sym_set_type(Symbol* s, const char* type){
    if(!s) return;
    if(s->type) free(s->type);
    s->type = xstrdup(type);
}
static void sym_set_return(Symbol* s, const char* r){
    if(!s) return;
    if(s->return_type) free(s->return_type);
    s->return_type = xstrdup(r);
}
static void sym_append_dims(Symbol* s, const char* dims){
    if(!s || !dims) return;
    size_t old = s->dimensions ? strlen(s->dimensions) : 0;
    size_t add = strlen(dims);
    char* p = (char*)malloc(old + add + 1);
    if(!p) return;
    if(old){ memcpy(p, s->dimensions, old); free(s->dimensions); }
    memcpy(p+old, dims, add);
    p[old+add]='\0';
    s->dimensions = p;
}
static void sym_append_params(Symbol* s, const char* params){
    if(!s || !params) return;
    const char* sep = s->param_lists ? " ; " : "";
    size_t old = s->param_lists ? strlen(s->param_lists) : 0;
    size_t add = strlen(sep) + strlen(params);
    char* p = (char*)malloc(old + add + 1);
    if(!p) return;
    if(old){ memcpy(p, s->param_lists, old); free(s->param_lists); }
    memcpy(p+old, sep, strlen(sep));
    memcpy(p+old+strlen(sep), params, strlen(params));
    p[old+add]='\0';
    s->param_lists = p;
}

typedef struct Constant {
    char* var_name;  
    int   line;
    char* value;     
    char* type;      
} Constant;

static Constant* consts = NULL;
static size_t nconsts = 0, capconsts = 0;

static void const_add(const char* var, int line, const char* val, const char* type){
    if(nconsts == capconsts){
        capconsts = capconsts ? capconsts*2 : 64;
        consts = (Constant*)realloc(consts, capconsts * sizeof(Constant));
    }
    consts[nconsts].var_name = xstrdup(var ? var : "-");
    consts[nconsts].line = line;
    consts[nconsts].value = xstrdup(val ? val : "");
    consts[nconsts].type = xstrdup(type ? type : "");
    nconsts++;
}

static int in_declaration = 0;
static char last_type[256] = {0};
static char last_ident[256] = {0};
static int last_was_ident = 0;
static int array_capture_for_ident = 0;
static int brace_depth = 0;
static int assignment_context = 0;  
static char pending_var[256] = {0}; /* Variable name for pending constant assignment */

static void start_declaration(const char* t){
    in_declaration = 1;
    last_type[0]='\0';
    if(t){ strncat(last_type, t, sizeof(last_type)-1); }
}
static void add_type_token(const char* t){
    if(last_type[0]) strncat(last_type, " ", sizeof(last_type)-1);
    strncat(last_type, t, sizeof(last_type)-1);
}
static void end_declaration(){
    in_declaration = 0;
    last_type[0]='\0';
    assignment_context = 0;
    pending_var[0] = '\0';
    array_capture_for_ident = 0;
}

static int paren_depth = 0;
static int capturing_args = 0;
static char* arg_buffer = NULL;
static size_t arg_cap = 0, arg_len = 0;
static Symbol* current_func_sym = NULL;

static void args_begin(Symbol* s){
    capturing_args = 1; paren_depth = 1; arg_len = 0;
    if(!arg_buffer){ arg_cap = 256; arg_buffer = (char*)malloc(arg_cap); }
    current_func_sym = s;
}
static void args_push_char(int c){
    if(!capturing_args) return;
    if(arg_len + 2 > arg_cap){
        arg_cap = arg_cap ? arg_cap*2 : 256;
        arg_buffer = (char*)realloc(arg_buffer, arg_cap);
    }
    arg_buffer[arg_len++] = (char)c;
    arg_buffer[arg_len] = '\0';
}

/* helper: find start index of last identifier in s, or -1 if none */
static int find_last_ident_pos(const char* s){
    if(!s) return -1;
    int i = (int)strlen(s) - 1;
    while(i >= 0){
        if(is_ident_char_c((unsigned char)s[i])){
            int end = i;
            int j = i;
            while(j >= 0 && is_ident_char_c((unsigned char)s[j])) j--;
            /* Now identifier is s[j+1 .. end] */
            return j+1;
        }
        i--;
    }
    return -1;
}

/* Parse arg_buffer to assign parameter types to symbols */
static void parse_and_register_params(const char* params_text){
    if(!params_text || !*params_text) return;

    int depth = 0; /* for nested parens (function pointers) */
    size_t n = strlen(params_text);
    size_t start = 0;

    for(size_t i=0; i<=n; ++i){
        int is_end = (i==n);
        char c = is_end ? ',' : params_text[i];

        if(!is_end){
            if(c=='(') depth++;
            else if(c==')' && depth>0) depth--;
        }
        if(c==',' && depth==0 || is_end){
            /* segment = params_text[start..i) */
            char* seg = xsubstr(params_text, start, i);
            trim(seg);
            if(seg[0]){
                /* skip 'void' and '...' */
                if(!(strcmp(seg,"void")==0 || strcmp(seg,"...")==0)){
                    int pos = find_last_ident_pos(seg);
                    if(pos >= 0){
                        /* name is seg[pos..] until non-ident */
                        int k = pos;
                        while(seg[k] && is_ident_char_c((unsigned char)seg[k])) k++;
                        char saved = seg[k];
                        seg[k] = '\0';
                        const char* name = seg + pos;

                        /* type is seg[0..pos) trimmed */
                        char* tpart = xsubstr(seg, 0, pos);
                        trim(tpart);

                        /* Touch symbol and set type if unknown */
                        Symbol* s = sym_touch(name);
                        if(tpart[0] && (!s->type || s->type[0]=='\0')){
                            sym_set_type(s, tpart);
                        }

                        /* restore and cleanup */
                        seg[k] = saved;
                        free(tpart);
                    }
                }
            }
            free(seg);
            start = i+1;
        }
    }
}

static void args_end(){
    if(capturing_args && current_func_sym){
        /* remove trailing ) if present */
        if(arg_len && arg_buffer[arg_len-1] == ')'){ arg_buffer[arg_len-1] = '\0'; }
        char* s = xstrdup(arg_buffer);
        trim(s);
        sym_append_params(current_func_sym, s);
        current_func_sym->is_function = 1;

        /* NEW: parse parameter text and assign types to parameter symbols */
        parse_and_register_params(s);

        free(s);
    }
    capturing_args = 0; paren_depth = 0; arg_len = 0; current_func_sym = NULL;
}

static void print_token(const char* kind, const char* lexeme){
    printf("[line %d] %-12s : %s\n", yylineno, kind, lexeme);
}

static const char* classify_int(const char* s){
    if(!s) return "int";
    if(strlen(s) > 2 && s[0]=='0' && (s[1]=='x'||s[1]=='X')) return "hex";
    if(strlen(s) > 2 && s[0]=='0' && (s[1]=='b'||s[1]=='B')) return "bin";
    if(s[0]=='0' && strlen(s)>1) return "oct";
    return "int";
}

#define YY_USER_ACTION /* placeholder */

%}

%x COMMENT
%x STRING
%x CHARLIT
%x PP
%x FUNCARGS

DIGIT      [0-9]
LETTER     [A-Za-z_]
ID         {LETTER}[A-Za-z0-9_]*
WS         [ \t\r]+

HEX        0[xX][0-9A-Fa-f]+
BIN        0[bB][01]+
OCT        0[0-7]+
INTSUFFIX  ([uU][lL]?|[lL][uU]?|[uU][lL][lL]|[lL][lL][uU]?)
EXP        ([eE][+-]?{DIGIT}+)
FLOAT1     {DIGIT}+"."{DIGIT}+({EXP})?
FLOAT2     {DIGIT}+"."({EXP})?
FLOAT3     "."{DIGIT}+({EXP})?
FLOAT4     {DIGIT}+{EXP}
FLOATSUF   [fFlL]?

ESC        (\\[abfnrtv\\'"?]|\\x[0-9A-Fa-f]+|\\[0-7]{1,3})

%%

^[ \t]*\#[^\n\\]*(\\\n[^\n\\]*)*    {
    print_token("PREPROC", yytext);
    char* tmp = xstrdup(yytext);
    char* p = tmp;
    while(*p==' '||*p=='\t') p++;
    if(*p=='#'){ p++; }
    while(*p==' ') p++;
    if(strncmp(p,"define",6)==0 && isspace((unsigned char)p[6])){
        p+=6; while(*p==' ') p++;
        char namebuf[256]={0};
        int i=0;
        while(*p && (isalnum((unsigned char)*p) || *p=='_')){
            if(i<255) namebuf[i++]=*p;
            p++;
        }
        namebuf[i]='\0';
        while(*p==' '||*p=='\t') p++;
        char* val = trim(p);
        if(val && namebuf[0]){
            const_add(namebuf, yylineno, val, "macro");
        }
    }
    free(tmp);
}

{WS}       { /* ignore */ }
\n         { /* newline handled by %option yylineno */ }

"//".*     { /* ignore */ }

"/*"       {
             BEGIN(COMMENT); int depth=1; int c1,c2;
             while(depth>0){
                c1 = input();
                if(c1==EOF){ fprintf(stderr,"[line %d] ERROR: Unterminated comment\n", yylineno); BEGIN(INITIAL); break; }
                if(c1=='\n'){ yylineno++; }  /* advance line count manually here */
                if(c1=='/'){
                    c2 = input();
                    if(c2=='*'){ depth++; }
                    else if(c2!=EOF){ unput(c2); }
                } else if(c1=='*'){
                    c2 = input();
                    if(c2=='/'){ depth--; }
                    else if(c2!=EOF){ unput(c2); }
                }
             }
             BEGIN(INITIAL);
           }

\"         { BEGIN(STRING); yyless(0); }
<STRING>\"([^"\\\n]|{ESC})*\"   {
             print_token("STRING", yytext);
             const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
             const_add(var_name, yylineno, yytext, "string");
             if(assignment_context) assignment_context = 0;
             BEGIN(INITIAL);
           }
<STRING>\"([^"\\\n]|{ESC})*\\\n    { /* continued line inside string */ }
<STRING>\n  { fprintf(stderr,"[line %d] ERROR: Unterminated string literal\n", yylineno-1); BEGIN(INITIAL); }
<STRING>.   { /* consume */ }

\'         { BEGIN(CHARLIT); yyless(0); }
<CHARLIT>\'([^'\\\n]|{ESC})+\'   {
             print_token("CHAR", yytext);
             const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
             const_add(var_name, yylineno, yytext, "char");
             if(assignment_context) assignment_context = 0;
             BEGIN(INITIAL);
           }
<CHARLIT>\n { fprintf(stderr,"[line %d] ERROR: Unterminated char literal\n", yylineno-1); BEGIN(INITIAL); }
<CHARLIT>.  { /* consume */ }

"auto"|"break"|"case"|"const"|"continue"|"default"|"do"|"else"|"enum"|"extern"|"for"|"goto"|"if"|"register"|"return"|"sizeof"|"static"|"struct"|"switch"|"typedef"|"union"|"volatile"|"while"|"inline"|"restrict"|"_Alignas"|"_Alignof"|"_Atomic"|"_Bool"|"_Complex"|"_Generic"|"_Imaginary"|"_Noreturn"|"_Static_assert"|"_Thread_local" {
    print_token("KEYWORD", yytext);
    last_was_ident = 0;
}

"void"|"char"|"short"|"int"|"long"|"float"|"double"|"signed"|"unsigned" {
    print_token("TYPE", yytext);
    if(!in_declaration) start_declaration(yytext);
    else add_type_token(yytext);
    last_was_ident = 0;
}

{ID}      {
    print_token("IDENT", yytext);
    Symbol* s = sym_touch(yytext);
    strncpy(last_ident, yytext, sizeof(last_ident)-1);
    last_ident[sizeof(last_ident)-1]='\0';
    last_was_ident = 1;

    /* Only allow array-dimension capture during declarations */
    array_capture_for_ident = in_declaration ? 1 : 0;

    if(in_declaration){
        if(!s->type && last_type[0]) sym_set_type(s, last_type);
    }
}

{HEX}{INTSUFFIX}?   {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "hex");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{BIN}{INTSUFFIX}?   {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "bin");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{FLOAT1}{FLOATSUF}? {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "float");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{FLOAT2}{FLOATSUF}? {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "float");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{FLOAT3}{FLOATSUF}? {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "float");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{FLOAT4}{FLOATSUF}? {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "float");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{OCT}{INTSUFFIX}?   {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, "oct");
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}
{DIGIT}+{INTSUFFIX}? {
    print_token("NUMBER", yytext);
    const char* var_name = (assignment_context && pending_var[0]) ? pending_var : "-";
    const_add(var_name, yylineno, yytext, classify_int(yytext));
    if(assignment_context) assignment_context = 0;
    last_was_ident = 0;
}

"("       {
            print_token("PUNCT", yytext);
            if(last_was_ident){
                Symbol* s = sym_lookup(last_ident);
                if(!s) s = sym_touch(last_ident);
                if(in_declaration || brace_depth == 0){
                    s->is_function = 1;
                    if(last_type[0]) sym_set_return(s, last_type);
                }
                args_begin(s);
                BEGIN(FUNCARGS);
            }
            last_was_ident = 0;
         }
<FUNCARGS>[^()\n]+   { for(size_t i=0;i<(size_t)yyleng;i++) args_push_char(yytext[i]); }
<FUNCARGS>"("        { args_push_char('('); paren_depth++; }
<FUNCARGS>")" {
    args_push_char(')');
    paren_depth--;
    if (paren_depth == 0) {
        args_end();
        print_token("PUNCT", yytext);
        BEGIN(INITIAL);
    }
}
<FUNCARGS>\n         { args_push_char('\n'); }

")"       { print_token("PUNCT", yytext); last_was_ident = 0; }

"["       { print_token("PUNCT", yytext); last_was_ident = 0; }
"]"       { print_token("PUNCT", yytext); last_was_ident = 0; }

"["{WS}*{DIGIT}+{WS}*"]"  {
            print_token("PUNCT", yytext);
            if(in_declaration && array_capture_for_ident){
                Symbol* s = sym_lookup(last_ident);
                if(s) sym_append_dims(s, yytext);
            }
            last_was_ident = 0;
         }

";"       {
    print_token("PUNCT", yytext);
    array_capture_for_ident = 0;
    if(in_declaration) end_declaration();
    last_was_ident = 0;
}
","       { print_token("PUNCT", yytext); array_capture_for_ident = 0; last_was_ident = 0; }
"{"       { print_token("PUNCT", yytext); brace_depth++; if(in_declaration) end_declaration(); last_was_ident = 0; }
"}"       { print_token("PUNCT", yytext); brace_depth--; last_was_ident = 0; }
"."|"->"  { print_token("OP", yytext); last_was_ident = 0; }

"++"|"--"                    { print_token("OP", yytext); last_was_ident = 0; }
"+="|"-="|"*="|"/="|"%="     { print_token("OP", yytext); last_was_ident = 0; }
"&="|"^="|"|="               { print_token("OP", yytext); last_was_ident = 0; }
"<<="|">>="                  { print_token("OP", yytext); last_was_ident = 0; }
"=="|"!="|"<="|">="          { print_token("OP", yytext); last_was_ident = 0; }
"<<"|">>"                    { print_token("OP", yytext); last_was_ident = 0; }
"&&"|"||"                    { print_token("OP", yytext); last_was_ident = 0; }
"+"|"-"|"*"|"/"|"%"          { print_token("OP", yytext); last_was_ident = 0; }
"<"|">"                      { print_token("OP", yytext); last_was_ident = 0; }
"!"|"~"|"&"|"^"              { print_token("OP", yytext); last_was_ident = 0; }
"|"                          { print_token("OP", yytext); last_was_ident = 0; }
"?"|":"                      { print_token("OP", yytext); last_was_ident = 0; }
"="                          {
    print_token("OP", yytext);
    array_capture_for_ident = 0; /* definitely not dimensions after '=' */
    if(last_was_ident) {
        assignment_context = 1;
        strncpy(pending_var, last_ident, sizeof(pending_var)-1);
        pending_var[sizeof(pending_var)-1] = '\0';
    }
    last_was_ident = 0;
}

.         { fprintf(stderr, "[line %d] ERROR: Invalid token '%s'\n", yylineno, yytext); }

<<EOF>>   {
            printf("\n************************************* SYMBOL TABLE *************************************\n");
            printf("%-20s %-15s %-12s %-10s %-15s %s\n", "Name", "Type", "Dimensions", "Frequency", "Return Type", "Parameters Lists in Function call");
            for(int i=0;i<SYM_HASH_SIZE;i++){
                for(Symbol* s=symtab[i]; s; s=s->next){
                    printf("%-20s %-15s %-12s %-10d %-15s %s\n",
                        s->name,
                        s->type ? s->type : "-",
                        s->dimensions ? s->dimensions : "-",
                        s->frequency,
                        s->return_type ? s->return_type : (s->is_function ? "unknown" : "-"),
                        s->param_lists ? s->param_lists : "-"
                    );
                }
            }
            printf("\n************************************* CONSTANT TABLE *************************************\n");
            printf("%-20s %-10s %-30s %s\n", "Variable Name", "Line No.", "Value", "Type");
            for(size_t i=0;i<nconsts;i++){
                printf("%-20s %-10d %-30s %s\n",
                    consts[i].var_name ? consts[i].var_name : "-",
                    consts[i].line,
                    consts[i].value ? consts[i].value : "",
                    consts[i].type ? consts[i].type : ""
                );
            }
            return 0;
          }

%%

int main(int argc, char** argv){
    if(argc > 1){
        FILE* f = fopen(argv[1], "r");
        if(!f){ perror("fopen"); return 1; }
        yyin = f;
    }
    yylex();
    return 0;
}
